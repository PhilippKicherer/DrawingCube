<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>AR Canvas Cube mit Touch-Drehung & Malfläche</title>
    <script src="https://aframe.io/releases/1.4.2/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.min.js"></script>
    <style>
      body, html {
        margin: 0; padding: 0; overflow: hidden; height: 100%;
        font-family: sans-serif;
      }
      canvas.drawingCanvas {
        position: fixed;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 33vh;
        touch-action: none;
        background: #fff;
        border-top: 2px solid #333;
        display: none;
      }
    </style>
  </head>
  <body>

    <canvas id="canvas1" class="drawingCanvas" width="512" height="512"></canvas>
    <canvas id="canvas2" class="drawingCanvas" width="512" height="512"></canvas>
    <canvas id="canvas3" class="drawingCanvas" width="512" height="512"></canvas>
    <canvas id="canvas4" class="drawingCanvas" width="512" height="512"></canvas>
    <canvas id="canvas5" class="drawingCanvas" width="512" height="512"></canvas>
    <canvas id="canvas6" class="drawingCanvas" width="512" height="512"></canvas>

    <a-scene embedded arjs="sourceType: webcam; debugUIEnabled: false;">
      <a-marker preset="hiro" id="marker">
        <a-entity id="cube" position="0 0.5 0" rotation="0 0 0" visible="true" scale="1 1 1">
          <a-plane position="0 0 0.5" width="1" height="1" rotation="0 0 0" material="shader: flat; src: #tex1; side: double"></a-plane>
          <a-plane position="0 0 -0.5" width="1" height="1" rotation="0 180 0" material="shader: flat; src: #tex2; side: double"></a-plane>
          <a-plane position="0.5 0 0" width="1" height="1" rotation="0 -90 0" material="shader: flat; src: #tex3; side: double"></a-plane>
          <a-plane position="-0.5 0 0" width="1" height="1" rotation="0 90 0" material="shader: flat; src: #tex4; side: double"></a-plane>
          <a-plane position="0 0.5 0" width="1" height="1" rotation="-90 0 0" material="shader: flat; src: #tex5; side: double"></a-plane>
          <a-plane position="0 -0.5 0" width="1" height="1" rotation="90 0 0" material="shader: flat; src: #tex6; side: double"></a-plane>
        </a-entity>
      </a-marker>

      <a-assets>
        <img id="tex1" />
        <img id="tex2" />
        <img id="tex3" />
        <img id="tex4" />
        <img id="tex5" />
        <img id="tex6" />
      </a-assets>

      <a-entity camera></a-entity>
    </a-scene>

    <script>
      const canvases = [
        document.getElementById("canvas1"),
        document.getElementById("canvas2"),
        document.getElementById("canvas3"),
        document.getElementById("canvas4"),
        document.getElementById("canvas5"),
        document.getElementById("canvas6"),
      ];

      const texImgs = [
        document.getElementById("tex1"),
        document.getElementById("tex2"),
        document.getElementById("tex3"),
        document.getElementById("tex4"),
        document.getElementById("tex5"),
        document.getElementById("tex6"),
      ];

      const cube = document.getElementById("cube");

      // Start: weiße Fläche mit Nummer
      canvases.forEach((canvas, i) => {
        const ctx = canvas.getContext("2d");
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "black";
        ctx.font = "bold 200px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(i + 1, canvas.width / 2, canvas.height / 2);
        texImgs[i].src = canvas.toDataURL();
      });

      let activeCanvasIndex = 0;

      function showActiveCanvas(index) {
        canvases.forEach((c, i) => {
          c.style.display = i === index ? "block" : "none";
        });
        activeCanvasIndex = index;
      }

      showActiveCanvas(0);

      // Mal-Logik
      let drawing = false;
      let lastPos = null;

      function getTouchPos(canvas, e) {
        const rect = canvas.getBoundingClientRect();
        if (e.touches) {
          return {
            x: e.touches[0].clientX - rect.left,
            y: e.touches[0].clientY - rect.top,
          };
        } else {
          return {
            x: e.clientX - rect.left,
            y: e.clientY - rect.top,
          };
        }
      }

      function startDrawing(e) {
        drawing = true;
        lastPos = getTouchPos(canvases[activeCanvasIndex], e);
      }
      function draw(e) {
        if (!drawing) return;
        e.preventDefault();
        const ctx = canvases[activeCanvasIndex].getContext("2d");
        const pos = getTouchPos(canvases[activeCanvasIndex], e);
        ctx.strokeStyle = "black";
        ctx.lineWidth = 5;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(lastPos.x, lastPos.y);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        lastPos = pos;
        texImgs[activeCanvasIndex].src = canvases[activeCanvasIndex].toDataURL();
      }
      function stopDrawing() {
        drawing = false;
        lastPos = null;
      }

      canvases.forEach((canvas) => {
        canvas.addEventListener("touchstart", startDrawing);
        canvas.addEventListener("touchmove", draw);
        canvas.addEventListener("touchend", stopDrawing);
        canvas.addEventListener("touchcancel", stopDrawing);
        canvas.addEventListener("mousedown", startDrawing);
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseup", stopDrawing);
        canvas.addEventListener("mouseleave", stopDrawing);
      });

      // Touch-Drehung Würfel
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      let rotation = { x: 0, y: 0, z: 0 };

      cube.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;
      });

      cube.addEventListener("touchmove", (e) => {
        e.preventDefault();
        if (!isDragging) return;
        let deltaX = e.touches[0].clientX - lastX;
        let deltaY = e.touches[0].clientY - lastY;
        lastX = e.touches[0].clientX;
        lastY = e.touches[0].clientY;

        rotation.x += deltaY * 0.5;
        rotation.y += deltaX * 0.5;

        // Begrenze X-Rotation zwischen -90 und 90 Grad (optional)
        rotation.x = Math.min(Math.max(rotation.x, -90), 90);

        cube.setAttribute("rotation", `${rotation.x} ${rotation.y} 0`);

        updateActiveCanvasFromRotation();
      });

      cube.addEventListener("touchend", (e) => {
        e.preventDefault();
        isDragging = false;
      });

      // Seite bestimmen anhand Rotation
      function updateActiveCanvasFromRotation() {
        const rotX = ((rotation.x % 360) + 360) % 360;
        const rotY = ((rotation.y % 360) + 360) % 360;

        let index;
        if (rotX > 45 && rotX < 135) {
          index = 4; // oben
        } else if (rotX > 225 && rotX < 315) {
          index = 5; // unten
        } else {
          if (rotY < 45 || rotY > 315) index = 0; // vorne
          else if (rotY >= 45 && rotY < 135) index = 3; // links
          else if (rotY >= 135 && rotY < 225) index = 1; // hinten
          else index = 2; // rechts
        }

        if (index !== activeCanvasIndex) {
          showActiveCanvas(index);
        }
      }

      // Marker gefunden => Canvas zeigen
      document.getElementById("marker").addEventListener("markerFound", () => {
        showActiveCanvas(activeCanvasIndex);
      });

      // Erstes Update bei Start
      updateActiveCanvasFromRotation();

    </script>
  </body>
</html>
